module BB2MD
  # Parse the quoted text
  class Quote
    attr_reader :text
    def initialize(text, id)
      @text = parse(text, id)
    end

    private

    def parse(text, id)
      # discourse doesn't support nested quotes
      # and you can't insert next line in quote
      regex = %r{\[quote(=&quot;(.*?)&quot;)?:#{id}\](.*)\[/quote:#{id}\]}m
      regex_short = %r{\[quote(=&quot;(.*?)&quot;)?:#{id}\](.*?)\[/quote:#{id}\]}m

      return text unless text =~ regex

      quoted_text = Regexp.last_match(3)

      inner_quotes = quoted_text.scan(regex_short)

      unless inner_quotes.empty?
        inner_quotes.each do |i|
          if i[1].nil?
            text.sub!("[quote:#{id}]#{i[2]}[/quote:#{id}]", "\s")
          else
            text.sub!("[quote#{i[0]}:#{id}]#{i[2]}[/quote:#{id}]", "\s")
          end
        end
      end

      m = text.scan(regex_short)
      return text if m.empty?

      m.each do |i|
        if i[1].nil?
          text.sub!("[quote:#{id}]#{i[2]}[/quote:#{id}]", "[quote]#{escape(i[2], id)}[/quote]")
        else
          text.sub!("[quote#{i[0]}:#{id}]#{i[2]}[/quote:#{id}]", "[quote#{i[0]}]#{escape(i[2], id)}[/quote]")
        end
      end

      text
    end

    def escape(text, id)
      # escape any code blocks
      text = text.gsub(%r{\[code.*?\].*?\[/code.*?\]}m, '~~original codes~~')
      # escape any list blocks
      text = BB2MD::List.new(text, id).instance_variable_get(:@tagged)
      text = text.gsub(%r{1-\[list.*?\].*?1-\[/list.*?\]}m, '~~original list~~')
      # escape 'sent from .* using *' generated by tapatalk
      text = text.gsub(/Sent\s+from.*?using\s+Tapatalk\s+2/m, '')
      # don't multi-line
      text.tr("\n", "\s")
    end
  end
end
